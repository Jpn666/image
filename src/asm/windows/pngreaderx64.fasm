;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Copyright (C) 2021, jpn jpn@gsforce.net
; 
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
; 
; http://www.apache.org/licenses/LICENSE-2.0
; 
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

format MS64 COFF


section '.code' code executable align 16


; In assertions:
; 1) the current row and prev row have 16 extra padding bytes to do SIMD
;    or loop unrolling
; 2) filter is non zero, "only valid values"  1, 2, 3, 4
; 3) pixel size is 1, 2, 3, 4, 6 or 8
; if any assertion is not meet the program may crash

public pngr_unfilterASM
; Parameters:
; (pointer) current row, (pointer) prev row, filter, row size, pel size

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Initialize the jump table according to the CPU capabilities
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SSE4_FLAG = 0180000h  ; sse4.1 | sse4.2


initjump:
	xor			rax, rax
	cmp			rax, qword[initdone]
	jne .done

	; preserve registers
	push		rcx
	push		rdx
	push		rbx

	mov			eax, 1
	cpuid
	and			ecx, SSE4_FLAG

	; sse2
	lea			rax, [sse2_f1]
	mov			qword[jumptable+1*8], rax
	lea			rax, [sse2_f2]
	mov			qword[jumptable+2*8], rax
	lea			rax, [sse2_f3]
	mov			qword[jumptable+3*8], rax
	lea			rax, [sse2_f4]
	mov			qword[jumptable+4*8], rax

	test		ecx, ecx
	jz .done

	; sse4
	lea			rax, [sse2_f4]
	mov			qword[jumptable+4*8], rax

.done:
	pop			rbx
	pop			rdx
	pop			rcx
	
	lea			rax, [initdone]
	mov			qword[rax], 1h
	jmp pngr_unfilterASM


pngr_unfilterASM:
	mov			r10, qword[rsp+8*5]  ; pelsize
	lea			rax, [jumptable]
	jmp qword[rax+r8*8]


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Scalar version
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

filter1:
	; curr + rowsize
	add			r9, rcx
	mov			rdx, rcx

	; curr + pelsize
	add			rcx, r10

.loop1:
	cmp			rcx,  r9
	jnb .done

	; a times per iteration
	rept 4 counter:0 {
		mov			al, byte[rdx+counter]
		add			byte[rcx+counter], al
	}

	add			rdx, 4
	add			rcx, 4
	jmp .loop1

.done:
	ret


filter2:
	; curr + rowsize
	add			r9, rcx

.loop1:
	cmp			rcx,  r9
	jnb .done

	; 4 bytes at time
	mov			r10b, byte[rdx+0]
	mov			r11b, byte[rdx+1]
	add			byte[rcx+0], r10b
	add			byte[rcx+1], r11b

	mov			r10b, byte[rdx+2]
	mov			r11b, byte[rdx+3]
	add			byte[rcx+2], r10b
	add			byte[rcx+3], r11b

	add			rcx, 4
	add			rdx, 4
	jmp .loop1

.done:
	ret


filter3:
	; curr + rowsize
	add			r9, rcx
	; curr + pelsize
	add			r10, rcx
	mov			r11, rcx
	push		r12
	
	; pelsize times
.loop1:
	cmp         rcx, r10
	jnb .loop2

	movzx		r12, byte[rdx]
	sar			r12, 1h
	add			byte[rcx], r12b
	inc			rcx
	inc			rdx
	jmp .loop1

.loop2:
	cmp			rcx,  r9
	jnb .done

	movzx		rax, byte[r11]
	movzx		r10, byte[rdx]
	add			rax, r10
	sar			rax, 1h
	add			byte[rcx], al

	inc			r11
	inc			rcx
	inc			rdx
	jmp .loop2

.done:
	pop			r12
	ret


filter4:
	; curr + rowsize
	add			r9, rcx
	; curr + pelsize
	add			r10, rcx
	mov			r11, rcx  ; becomes [curr - pelsize] after the first loop
	mov			r8, rdx  ; becomes [prev - pelsize] after the first loop
	push		r15
	push		r14
	push		r13
	push		r12
	push		rdi
	push		rsi
	push		rbx
	mov			rbx, rdx

.loop1:
	cmp			rcx,  r10
	jnb .loop2

	mov			r12b, byte[rbx]
	add			byte[rcx], r12b
	inc			rbx
	inc			rcx
	jmp .loop1

.loop2:
	cmp			rcx,  r9
	jnb .done
	
	movzx		r10, byte[r11] ; a
	movzx		r12, byte[rbx] ; b
	movzx		r13, byte[ r8] ; c

	; p
	mov			rdi, r12
	add			rdi, r10
	sub			rdi, r13

	; r14 := pa; r15 := pb; rsi := pc
	mov			rax, rdi
	sub			rax, r10
	cqo
	xor			rax, rdx
	sub			rax, rdx
	mov			r14, rax

	mov			rax, rdi
	sub			rax, r12
	cqo
	xor			rax, rdx
	sub			rax, rdx
	mov			r15, rax

	mov			rax, rdi
	sub			rax, r13
	cqo
	xor			rax, rdx
	sub			rax, rdx
	mov			rsi, rax

	; result is in r10 (a)
	mov			rax, r15
	mov			rdx, rsi
	sub			rax, r14
	sub			rdx, r14
	inc			rbx
	inc			r11
	or			rax, rdx 
	jns .pickdone

	; pick b
	mov			r10, r12
	cmp			r15, rsi
	cmova		r10, r13

.pickdone:
	add			byte[rcx], r10b
	inc			 r8
	inc			rcx
	jmp .loop2

.done:
	pop			rbx
	pop			rsi
	pop			rdi
	pop			r12
	pop			r13
	pop			r14
	pop			r15
	ret


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SSE2 version
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

sse2_f1:
	; use the scalar version is pelsize is <= 2
	cmp			r10, 2
	jbe filter1

	; curr + rowsize
	add			r9, rcx
	pxor		xmm0, xmm0  ; zero
	pxor		xmm1, xmm1  ; [curr - pelsize]

	; calculate the jump to set the pixel
	mov			r11, 8
	sub			r11, r10
	lea			rax, [.setpel]
	lea			r11, [rax+r11*8]
	sub			rsp, 10h

.loop1:
	cmp			rcx,  r9
	jnb .done

	movdqu		xmm2, [rcx]
	punpcklbw	xmm2, xmm0

	paddw		xmm2, xmm1

	movdqu		[rsp], xmm2
	jmp near r11

.setpel:
	rept 8 counter:0 { reverse
		mov			ax, word[rsp+counter*2]
		mov			byte[rcx+counter], al
	}
	nop

	movdqa		xmm1, xmm2
	add			rcx, r10
	jmp .loop1

.done:
	add			  rsp, 10h
	ret


sse2_f2:
	add			 r9, rcx  ; row size + current

.loop1:
	cmp			rcx,  r9
	jnb .done

	movdqu		xmm0, [rcx]
	movdqu		xmm1, [rdx]
	paddb		xmm0, xmm1
	movdqu		[rcx], xmm0

	add			rcx, 10h
	add			rdx, 10h
	jmp .loop1

.done:
	ret


align 16
andmask:
	db 16 dup(1h)

sse2_f3:
	; use the scalar version is pelsize is <= 2
	cmp			r10, 2
	jbe filter3

	add			r9, rcx  ; row size + current

	; calculate the jump to set the pixel
	mov			r11, 8
	sub			r11, r10
	lea			rax, [.setpel]
	lea			r11, [rax+r11*8]

	; preserve xmm6
	sub			 rsp, 10h
	movdqu		 [rsp], xmm6

	pxor		xmm0, xmm0  ; zero
	pxor		xmm1, xmm1
	movdqa		xmm6, [andmask]

	sub			rsp, 10h

.loop1:
	cmp			rcx,  r9
	jnb .done

	; xmm1 := [curr]; xmm2 := a; xmm3 := b;
	movdqa		xmm2, xmm1
	movdqu		xmm1, [rcx]
	movdqu		xmm3, [rdx]

	movdqa		xmm4, xmm2
	movdqa		xmm5, xmm2
	pavgb		xmm4, xmm3
	pxor		xmm5, xmm3
	pand		xmm5, xmm6
	psubb		xmm4, xmm5
	paddb		xmm1, xmm4
	movdqa		xmm2, xmm1
	punpcklbw	xmm2, xmm0

	movdqu		[rsp], xmm2
	jmp near r11

.setpel:
	rept 8 counter:0 { reverse
		mov			ax, word[rsp+counter*2]
		mov			byte[rcx+counter], al
	}
	nop
	add			rcx, r10
	add			rdx, r10
	jmp .loop1

.done:
	add			rsp, 10h
	movdqu		xmm6, [rsp]
	add			rsp, 10h
	ret


sse2_f4:
	; use the scalar version is pelsize is == 1
	cmp			r10, 1
	je filter4
	
	add			 r9, rcx  ; row size + current
	
	pxor		xmm1, xmm1 ; a
	pxor		xmm2, xmm2 ; b
	pxor		xmm3, xmm3 ; c
	pxor		xmm4, xmm4 ; x
	pxor		xmm5, xmm5 ; zero
	
	; calculate the jump to set the pixel
	mov			r11, 8
	sub			r11, r10
	lea			rax, [.setpel]
	lea			r11, [rax+r11*8]
	
	; preserve xmm6, xmm7, xmm8, and xmm9
	sub			 rsp, 40h
	movdqu		[rsp+ 0h], xmm6
	movdqu		[rsp+10h], xmm7
	movdqu		[rsp+20h], xmm8
	movdqu		[rsp+30h], xmm9
	sub			 rsp, 10h
	
.loop1:
	cmp			rcx,  r9
	jnb .done

	movdqa		xmm3, xmm2   ; c = b
	movdqu		xmm2, [rdx]  ; b = prev
	movdqa		xmm1, xmm4   ; a = x
	movdqu		xmm4, [rcx]  ; x = curr
	punpcklbw	xmm2, xmm5
	punpcklbw	xmm4, xmm5

	; pa = b - c
	movdqa		xmm6, xmm2
	psubw		xmm6, xmm3
	; pb = a - c
	movdqa		xmm7, xmm1
	psubw		xmm7, xmm3
	; pc = pb + pb
	movdqa		xmm8, xmm7 
	paddw		xmm8, xmm6

	; abs(pa)
	movdqa		xmm9, xmm6
	psraw		xmm9, 15
	pxor		xmm6, xmm9
	psubw		xmm6, xmm9

	; abs(pb)
	movdqa		xmm9, xmm7
	psraw		xmm9, 15
	pxor		xmm7, xmm9
	psubw		xmm7, xmm9

	; abs(pc)
	movdqa		xmm9, xmm8
	psraw		xmm9, 15
	pxor		xmm8, xmm9
	psubw		xmm8, xmm9

	; xmm9 = min(pc, min(pa, pb))
	movdqa		xmm9, xmm6
	pminsw		xmm9, xmm7 ; min(pa, pb)
	pminsw		xmm9, xmm8 ; min(min(pa, pb), pc) := sm

	pcmpeqw		xmm6, xmm9  ; min(pa, min(pc, min(pa, pb))); mask1
	pcmpeqw		xmm7, xmm9  ; min(pb, min(pc, min(pa, pb))); mask2

	movdqa		xmm9, xmm7  ; andnot(min(pb..), c) := 1 

	pandn		xmm9, xmm3  ; andnot(mask1, c)
	pand		xmm7, xmm2  ; and(mask1, b)
	por			xmm9, xmm7  ; or (1, 2) := v

	movdqa		xmm0, xmm6
	pandn		xmm0, xmm9 ; andnot(min(pa..), v)   := 3
	pand		xmm6, xmm1 ; and(min(pa..), a)      := 4
	por			xmm0, xmm6 ; or(3, 4)

	movdqa		xmm9, xmm0
	paddb		xmm4, xmm9

	movdqu		[rsp], xmm4
	jmp near r11

.setpel:
	rept 8 counter:0 { reverse
		mov			ax, word[rsp+counter*2]
		mov			byte[rcx+counter], al
	}
	nop

	add			rcx, r10
	add			rdx, r10
	jmp .loop1

.done:
	add			rsp, 10h
	movdqu		xmm6, [rsp+ 0h]
	movdqu		xmm7, [rsp+10h]
	movdqu		xmm8, [rsp+20h]
	movdqu		xmm9, [rsp+30h]
	add			rsp, 40h
	ret


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SSE4 version
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

sse4_f4:
	; use the scalar version is pelsize is == 1
	cmp			r10, 1
	je filter4

	add			r9, rcx  ; row size + current

	pxor		xmm1, xmm1 ; a
	pxor		xmm2, xmm2 ; b
	pxor		xmm3, xmm3 ; c
	pxor		xmm4, xmm4 ; x
	pxor		xmm5, xmm5 ; zero

	; calculate the jump to set the pixel
	mov			r11, 8
	sub			r11, r10
	lea			rax, [.setpel]
	lea			r11, [rax+r11*8]

	; preserve xmm6, xmm7, xmm8, and xmm9
	sub			rsp, 40h
	movdqu		[rsp+ 0h], xmm6
	movdqu		[rsp+10h], xmm7
	movdqu		[rsp+20h], xmm8
	movdqu		[rsp+30h], xmm9
	sub			rsp, 10h

.loop1:
	cmp			rcx,  r9
	jnb .done

	movdqa		xmm3, xmm2   ; c = b
	movdqu		xmm2, [rdx]  ; b = prev
	movdqa		xmm1, xmm4   ; a = x
	movdqu		xmm4, [rcx]  ; x = curr
	punpcklbw	xmm2, xmm5
	punpcklbw	xmm4, xmm5

	movdqa		xmm6, xmm2
	psubw		xmm6, xmm3  ; pa = b - c
	movdqa		xmm7, xmm1
	psubw		xmm7, xmm3  ; pb = a - c
	movdqa		xmm8, xmm7 
	paddw		xmm8, xmm6  ; pc = pb + pb

	pabsw		xmm6, xmm6
	pabsw		xmm7, xmm7
	pabsw		xmm8, xmm8

	movdqa		xmm9, xmm6
	pminsw		xmm9, xmm7  ; min(pa, pb)
	pminsw		xmm9, xmm8  ; min(min(pa, pb), pc) := sm

	pcmpeqw		xmm6, xmm9  ; min(pa, min(pc, min(pa, pb))); mask1
	pcmpeqw		xmm7, xmm9  ; min(pb, min(pc, min(pa, pb))); mask2

	;
	movdqa		xmm0, xmm7
	movdqa		xmm9, xmm3
	pblendvb	xmm9, xmm2  ; blend(c, b) := 5

	movdqa		xmm0, xmm6
	pblendvb	xmm9, xmm1  ; blend(5, a)

	paddb		xmm4, xmm9

	movdqu		[rsp], xmm4
	jmp near r11

.setpel:
	rept 8 counter:0 { reverse
		mov			ax, word[rsp+counter*2]
		mov			byte[rcx+counter], al
	}
	nop

	add			rcx, r10
	add			rdx, r10
	jmp .loop1

.done:
	add			rsp, 10h
	movdqu		xmm6, [rsp+ 0h]
	movdqu		xmm7, [rsp+10h]
	movdqu		xmm8, [rsp+20h]
	movdqu		xmm9, [rsp+30h]
	add			rsp, 40h
	ret


dummy:
	ret


section '.data' align 16

jumptable:
	dq		dummy
	dq		initjump
	dq		initjump
	dq		initjump
	dq		initjump

initdone:
	dq		0h

